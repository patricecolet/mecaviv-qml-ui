/**
 * API de contr√¥le des sir√®nes - Gestion des takeovers
 */

const express = require('express');
const router = express.Router();

// √âtat des connexions actives
const activeConnections = new Map(); // sireneId -> { sourceId, timestamp, metadata }

// Notifications WebSocket
let notifyConsoles = () => {};

function setNotifyFunction(notifyFn) {
    notifyConsoles = notifyFn;
}

/**
 * POST /api/control/request
 * Demande de contr√¥le d'une sir√®ne - Syst√®me simple "dernier arriv√©, premier servi"
 */
router.post('/request', async (req, res) => {
    try {
        const { sourceId, sireneId, metadata = {} } = req.body;
        
        if (!sourceId || !sireneId) {
            return res.status(400).json({
                error: 'sourceId et sireneId requis'
            });
        }
        
        console.log(`üéõÔ∏è Demande de contr√¥le: ${sourceId} ‚Üí S${sireneId}`);
        
        const currentConnection = activeConnections.get(sireneId);
        const requestId = generateRequestId();
        
        // Si la sir√®ne est libre
        if (!currentConnection) {
            // Accorder le contr√¥le imm√©diatement
            activeConnections.set(sireneId, {
                sourceId,
                timestamp: Date.now(),
                requestId,
                metadata
            });
            
            console.log(`‚úÖ Contr√¥le accord√©: ${sourceId} ‚Üí S${sireneId}`);
            
            // Notifier les consoles
            notifyConsoles({
                type: 'control_granted',
                data: {
                    sireneId,
                    sourceId,
                    requestId,
                    timestamp: Date.now()
                }
            });
            
            return res.json({
                status: 'granted',
                requestId,
                sireneId,
                sourceId,
                grantedAt: new Date().toISOString()
            });
        }
        
        // Si la sir√®ne est occup√©e - takeover avec timeout
        const currentSource = currentConnection.sourceId;
        const { force = false, timeout = 5000 } = req.body;
        
        console.log(`üîÑ Demande de takeover: ${currentSource} ‚Üí ${sourceId} (S${sireneId}) [force: ${force}, timeout: ${timeout}ms]`);
        
        if (force) {
            // Mode for√ßage - pas d'attente
            console.log(`üî® For√ßage du takeover: ${currentSource} ‚Üí ${sourceId} (S${sireneId})`);
            
            // Notifier la source actuelle qu'elle est d√©connect√©e de force
            notifyConsoles({
                type: 'control_force_revoked',
                data: {
                    sireneId,
                    sourceId: currentSource,
                    reason: 'force_takeover',
                    newController: sourceId,
                    requestId: currentConnection.requestId,
                    timestamp: Date.now()
                }
            });
            
            // Accorder imm√©diatement le contr√¥le √† la nouvelle source
            activeConnections.set(sireneId, {
                sourceId,
                timestamp: Date.now(),
                requestId,
                metadata
            });
            
            console.log(`‚úÖ Contr√¥le forc√©: ${currentSource} ‚Üí ${sourceId} (S${sireneId})`);
            
            // Notifier les consoles
            notifyConsoles({
                type: 'control_granted',
                data: {
                    sireneId,
                    sourceId,
                    requestId,
                    timestamp: Date.now(),
                    previousController: currentSource,
                    forced: true
                }
            });
            
            return res.json({
                status: 'granted',
                requestId,
                sireneId,
                sourceId,
                grantedAt: new Date().toISOString(),
                takeover: true,
                forced: true,
                previousController: currentSource
            });
        } else {
            // Mode normal - attendre confirmation avec timeout
            console.log(`‚è±Ô∏è Takeover normal avec timeout de ${timeout}ms`);
            
            // Notifier la source actuelle qu'elle doit se d√©connecter
            notifyConsoles({
                type: 'control_revoked',
                data: {
                    sireneId,
                    sourceId: currentSource,
                    reason: 'new_source_request',
                    newController: sourceId,
                    requestId: currentConnection.requestId,
                    timestamp: Date.now()
                }
            });
            
            // Attendre la confirmation avec timeout
            const confirmationReceived = await waitForConfirmation(currentSource, sireneId, timeout);
            
            if (confirmationReceived) {
                // Confirmation re√ßue - accorder le contr√¥le
                activeConnections.set(sireneId, {
                    sourceId,
                    timestamp: Date.now(),
                    requestId,
                    metadata
                });
                
                console.log(`‚úÖ Contr√¥le transf√©r√© (confirm√©): ${currentSource} ‚Üí ${sourceId} (S${sireneId})`);
                
                // Notifier les consoles
                notifyConsoles({
                    type: 'control_granted',
                    data: {
                        sireneId,
                        sourceId,
                        requestId,
                        timestamp: Date.now(),
                        previousController: currentSource
                    }
                });
                
                return res.json({
                    status: 'granted',
                    requestId,
                    sireneId,
                    sourceId,
                    grantedAt: new Date().toISOString(),
                    takeover: true,
                    previousController: currentSource
                });
            } else {
                // Timeout - forcer la lib√©ration
                console.log(`‚è∞ Timeout - for√ßage du takeover: ${currentSource} ‚Üí ${sourceId} (S${sireneId})`);
                
                // Notifier la source actuelle qu'elle est d√©connect√©e de force
                notifyConsoles({
                    type: 'control_force_revoked',
                    data: {
                        sireneId,
                        sourceId: currentSource,
                        reason: 'timeout_force',
                        newController: sourceId,
                        requestId: currentConnection.requestId,
                        timestamp: Date.now()
                    }
                });
                
                // Accorder le contr√¥le apr√®s timeout
                activeConnections.set(sireneId, {
                    sourceId,
                    timestamp: Date.now(),
                    requestId,
                    metadata
                });
                
                console.log(`‚úÖ Contr√¥le forc√© (timeout): ${currentSource} ‚Üí ${sourceId} (S${sireneId})`);
                
                // Notifier les consoles
                notifyConsoles({
                    type: 'control_granted',
                    data: {
                        sireneId,
                        sourceId,
                        requestId,
                        timestamp: Date.now(),
                        previousController: currentSource,
                        timeoutForced: true
                    }
                });
                
                return res.json({
                    status: 'granted',
                    requestId,
                    sireneId,
                    sourceId,
                    grantedAt: new Date().toISOString(),
                    takeover: true,
                    timeoutForced: true,
                    previousController: currentSource
                });
            }
        }
        
    } catch (error) {
        console.error('Erreur lors de la demande de contr√¥le:', error);
        res.status(500).json({
            error: 'Erreur interne du serveur'
        });
    }
});

/**
 * POST /api/control/release
 * Lib√©ration du contr√¥le d'une sir√®ne
 */
router.post('/release', (req, res) => {
    try {
        const { sourceId, sireneId, requestId } = req.body;
        
        if (!sourceId || !sireneId) {
            return res.status(400).json({
                error: 'sourceId et sireneId requis'
            });
        }
        
        const currentConnection = activeConnections.get(sireneId);
        
        if (!currentConnection) {
            return res.json({
                status: 'already_free',
                sireneId
            });
        }
        
        if (currentConnection.sourceId !== sourceId) {
            return res.status(403).json({
                error: 'Source non autoris√©e √† lib√©rer cette sir√®ne',
                currentController: currentConnection.sourceId
            });
        }
        
        // Lib√©rer la sir√®ne
        activeConnections.delete(sireneId);
        
        console.log(`üîì Contr√¥le lib√©r√©: ${sourceId} ‚Üí S${sireneId}`);
        
        // Notifier les consoles
        notifyConsoles({
            type: 'control_released',
            data: {
                sireneId,
                sourceId,
                requestId: currentConnection.requestId,
                timestamp: Date.now()
            }
        });
        
        res.json({
            status: 'released',
            sireneId,
            sourceId,
            releasedAt: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('Erreur lors de la lib√©ration:', error);
        res.status(500).json({
            error: 'Erreur interne du serveur'
        });
    }
});

/**
 * GET /api/control/status
 * √âtat des connexions actives
 */
router.get('/status', (req, res) => {
    const connections = {};
    
    for (const [sireneId, connection] of activeConnections.entries()) {
        connections[sireneId] = {
            sourceId: connection.sourceId,
            timestamp: connection.timestamp,
            requestId: connection.requestId,
            priority: connection.priority,
            metadata: connection.metadata
        };
    }
    
    res.json({
        activeConnections: connections,
        totalConnections: activeConnections.size
    });
});

/**
 * POST /api/control/force-release
 * Force la lib√©ration d'une sir√®ne (admin uniquement)
 */
router.post('/force-release', (req, res) => {
    try {
        const { sireneId, reason = 'admin_override' } = req.body;
        
        const currentConnection = activeConnections.get(sireneId);
        
        if (!currentConnection) {
            return res.json({
                status: 'already_free',
                sireneId
            });
        }
        
        const sourceId = currentConnection.sourceId;
        const requestId = currentConnection.requestId;
        
        // Force la lib√©ration
        activeConnections.delete(sireneId);
        
        console.log(`üî® Lib√©ration forc√©e: ${sourceId} ‚Üí S${sireneId} (${reason})`);
        
        // Notifier la source qu'elle a √©t√© d√©connect√©e
        notifyConsoles({
            type: 'control_force_revoked',
            data: {
                sireneId,
                sourceId,
                reason,
                requestId,
                timestamp: Date.now()
            }
        });
        
        res.json({
            status: 'force_released',
            sireneId,
            previousController: sourceId,
            reason,
            releasedAt: new Date().toISOString()
        });
        
    } catch (error) {
        console.error('Erreur lors de la lib√©ration forc√©e:', error);
        res.status(500).json({
            error: 'Erreur interne du serveur'
        });
    }
});

/**
 * G√©n√©rer un ID de requ√™te unique
 */
function generateRequestId() {
    return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Attendre la confirmation de lib√©ration avec timeout
 */
async function waitForConfirmation(sourceId, sireneId, timeout) {
    return new Promise((resolve) => {
        const timeoutId = setTimeout(() => {
            console.log(`‚è∞ Timeout de confirmation pour ${sourceId} ‚Üí S${sireneId}`);
            resolve(false);
        }, timeout);
        
        // √âcouter les lib√©rations de cette source pour cette sir√®ne
        const originalNotify = notifyConsoles;
        notifyConsoles = (notification) => {
            // Appeler la fonction originale
            originalNotify(notification);
            
            // V√©rifier si c'est une lib√©ration de la source attendue
            if (notification.type === 'control_released' && 
                notification.data.sourceId === sourceId && 
                notification.data.sireneId === sireneId) {
                clearTimeout(timeoutId);
                console.log(`‚úÖ Confirmation re√ßue de ${sourceId} pour S${sireneId}`);
                notifyConsoles = originalNotify; // Restaurer la fonction originale
                resolve(true);
            }
        };
    });
}

/**
 * Nettoyage p√©riodique des connexions expir√©es
 */
setInterval(() => {
    const now = Date.now();
    const maxAge = 5 * 60 * 1000; // 5 minutes
    
    for (const [sireneId, connection] of activeConnections.entries()) {
        if (now - connection.timestamp > maxAge) {
            console.log(`üßπ Connexion expir√©e nettoy√©e: ${connection.sourceId} ‚Üí S${sireneId}`);
            activeConnections.delete(sireneId);
            
            notifyConsoles({
                type: 'control_expired',
                data: {
                    sireneId,
                    sourceId: connection.sourceId,
                    requestId: connection.requestId,
                    timestamp: now
                }
            });
        }
    }
}, 60000); // V√©rification toutes les minutes

module.exports = { router, setNotifyFunction };
